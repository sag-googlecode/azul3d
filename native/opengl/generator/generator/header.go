// Copyright 2012 Lightpoke. All rights reserved.
// This source code is subject to the terms and
// conditions defined in the "License.txt" file.
//
// Code generated by this program is also under
// the above license.

package generator

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func generateHeader(packageDir, prefix string, versionProcs, possibleProcs []*Procedure) {
	// We don't care about required vs. non-required procedures here.. this is just the C invoke
	// wrapper.
	versionProcs = append(versionProcs, possibleProcs...)

	header, err := os.Create(filepath.Join(packageDir, prefix+".h"))
	if err != nil {
		log.Fatal(err)
	}
	defer header.Close()

	fmt.Fprintf(header, "#include <stdbool.h>\n")
	fmt.Fprintf(header, "#include <stdlib.h>\n")
	fmt.Fprintf(header, `
typedef char GLchar;
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;
typedef ptrdiff_t GLsizeiptr;
typedef ptrdiff_t GLintptr;
`)
	fmt.Fprintf(header, "\n")

	for _, p := range versionProcs {
		procArgs := new(bytes.Buffer)
		for i, arg := range p.Takes {
			if arg != "void" {
				split := strings.Split(arg, " ")
				argType := split[0]

				fmt.Fprintf(procArgs, argType)

				if i != len(p.Takes)-1 {
					fmt.Fprintf(procArgs, ", ")
				}
			}
		}

		glStripped := strings.TrimLeft(p.Name, "gl")
		fmt.Fprintf(header, "typedef %s(*%sP%s)(%s);\n", p.Returns, prefix, glStripped, procArgs.Bytes())
	}
	fmt.Fprintf(header, "\n")

	fmt.Fprintf(header, "typedef struct {\n")
	for _, p := range versionProcs {
		glStripped := strings.TrimLeft(p.Name, "gl")
		fmt.Fprintf(header, "    %sP%s fn%s;\n", prefix, glStripped, glStripped)
	}
	fmt.Fprintf(header, "} %sContext;\n\n", prefix)

	fmt.Fprintf(header, "extern %sContext* %sNewContext();\n", prefix, prefix)

	// Invokers
	for _, p := range versionProcs {
		glStripped := strings.TrimLeft(p.Name, "gl")

		fmt.Fprintf(header, "%s %s%s(", p.Returns, prefix, glStripped)
		fmt.Fprintf(header, "%sContext* glc", prefix)
		for i, arg := range p.Takes {
			if arg != "void" {
				if i == 0 {
					fmt.Fprintf(header, ", ")
				}

				fmt.Fprintf(header, arg)

				if i != len(p.Takes)-1 {
					fmt.Fprintf(header, ", ")
				}
			}
		}
		fmt.Fprintf(header, ");\n")
	}
}
