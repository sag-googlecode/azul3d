// Copyright 2012 Lightpoke. All rights reserved.
// This source code is subject to the terms and
// conditions defined in the "License.txt" file.
//
// Code generated by this program is also under
// the above license.

package generator

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func generateC(packageDir, prefix, version, versionWithoutDots string, versionProcs, possibleProcs []*Procedure) {
	// We don't care about required vs. non-required procedures here.. this is just the C invoke
	// wrapper.
	versionProcs = append(versionProcs, possibleProcs...)

	api, err := os.Create(filepath.Join(packageDir, prefix+".c"))
	if err != nil {
		log.Fatal(err)
	}
	defer api.Close()

	cHelperCode := `
#include <stdbool.h>
#include <stdlib.h>

#ifdef _WIN32
#include <windows.h>
#endif

#include "gl<VERSION_WITHOUT_DOTS>.h"

#ifdef _WIN32
HMODULE gl<VERSION_WITHOUT_DOTS>OpenGL32;

void* gl<VERSION_WITHOUT_DOTS>LibGetProcAddress(char* name) {
	if(gl<VERSION_WITHOUT_DOTS>OpenGL32 == NULL) {
		gl<VERSION_WITHOUT_DOTS>OpenGL32 = LoadLibrary(TEXT("opengl32.dll"));
	}
	return GetProcAddress(gl<VERSION_WITHOUT_DOTS>OpenGL32, TEXT(name));
}

void* gl<VERSION_WITHOUT_DOTS>GLGetProcAddress(char* name) {
	void* ptr = wglGetProcAddress(name);

	intptr_t iptr = (intptr_t)ptr;

	if(iptr == 0 || iptr == 1 || iptr == 2 || iptr == 3 || iptr == -1) {
		return NULL;
	}
	return ptr;
}
#endif
`

	cHelperCode = strings.Replace(cHelperCode, "<VERSION>", version, -1)
	cHelperCode = strings.Replace(cHelperCode, "<VERSION_WITHOUT_DOTS>", versionWithoutDots, -1)
	api.Write([]byte(cHelperCode))
	fmt.Fprintf(api, "\n\n")

	for _, p := range versionProcs {
		glStripped := strings.TrimLeft(p.Name, "gl")

		procArgs := new(bytes.Buffer)
		procArgNames := new(bytes.Buffer)
		for i, arg := range p.Takes {
			if arg != "void" {
				split := strings.Split(arg, " ")
				argType := split[0]
				argName := split[1]

				fmt.Fprintf(procArgs, argType)
				fmt.Fprintf(procArgNames, argName)

				if i != len(p.Takes)-1 {
					fmt.Fprintf(procArgs, ", ")
					fmt.Fprintf(procArgNames, ", ")
				}
			}
		}

		// The invoker, which simply calls the proc *assuming* it exists
		fmt.Fprintf(api, "%s %s%s(", p.Returns, prefix, glStripped)
		fmt.Fprintf(api, "%sContext* glc", prefix)
		for i, arg := range p.Takes {
			if arg != "void" {
				if i == 0 {
					fmt.Fprintf(api, ", ")
				}

				fmt.Fprintf(api, arg)

				if i != len(p.Takes)-1 {
					fmt.Fprintf(api, ", ")
				}
			}
		}
		fmt.Fprintf(api, ") {\n")
		fmt.Fprintf(api, "    return glc->fn%s(%s);\n", glStripped, procArgNames.Bytes())
		fmt.Fprintf(api, "}\n\n")
	}

	fmt.Fprintf(api, "%sContext* %sNewContext() {\n", prefix, prefix)
	fmt.Fprintf(api, "    %sContext* glc = calloc(1, sizeof(%sContext));\n", prefix, prefix)
	fmt.Fprintf(api, "\n")
	fmt.Fprintf(api, "    // Preload all procedures\n")
	for _, p := range versionProcs {
		glStripped := strings.TrimLeft(p.Name, "gl")

		fmt.Fprintf(api, "    glc->fn%s = (%sP%s)", glStripped, prefix, glStripped)
		if !p.Extension {
			fmt.Fprintf(api, "gl%sLibGetProcAddress(\"%s\");\n", versionWithoutDots, p.Name)
		} else {
			fmt.Fprintf(api, "gl%sGLGetProcAddress(\"%s\");\n", versionWithoutDots, p.Name)
		}
	}
	fmt.Fprintf(api, "    return glc;\n")
	fmt.Fprintf(api, "}\n\n")
}
